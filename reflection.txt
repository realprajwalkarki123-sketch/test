While developing the Student Grading System, my very first approach was a brute-force method, where I focused primarily on understanding the problem and producing output in any working form. At first, I did not worry much about optimization or structure cause my goal was to ensure that the program could store student information, calculate scores, and display results. As I started writing code, I realized that a more organized approach was necessary, so I started breaking down the program into separate functions, such as calculate_overall_score(), round_to_category(), and other helper functions. This modular approach allowed me to optimize each functionality individually, making the program more robust and easier to debug.

The modular approach worked particularly well because the system has two modes for handling student data: a manual entry mode and an advanced mode that allows importing data from a CSV file. Each mode required different processing steps but somehow I was able to reuse code and maintain consistency across both workflows. Additionally, using Python libraries such as datetime for age calculations and tabulate for formatted output saved a lot of time and effort

 Flowcharts were particularly helpful for understanding and visualizing the logical flow of the system. Given the complexity of the score calculation and category rounding, having a visual representation made it easier to anticipate potential issues and ensure that all conditional branches were correctly implemented.

Bugs and errors were inevitable during development, particularly related to input validation, unique student IDs, and file handling. I tackled these challenges by implementing extensive error handling using try-except blocks, printing intermediate outputs for debugging, and checking small cases individually. These steps allowed me to identify issues and correct them to make a stable program.

The most difficult part of this coursework was designing the score rounding and categorization system. Mapping continuous numeric scores to discrete categories like "Third," "Upper Second," or "Gold Standard" required careful attention to avoid errors and all. Testing edge cases extensively helped ensure accuracy, but it was time-consuming and required patience.

If I had no time limit, I would further improve the program by separating each module into individual files, creating a more structured project architecture. I would also implement additional edge case testing, introduce a graphical user interface (GUI), and possibly switch to a database system for better data management. These improvements would enhance scalability, maintainability, and overall usability.

Overall, this project taught me the value of modular programming, systematic debugging, and careful planning. It strengthened my understanding of program decomposition, data validation, and integrating multiple functionalities into a cohesive system. I particularly enjoyed designing reusable functions for score calculations, as they provided clarity and efficiency while solving the problem.